package backjoon.`20260221`

import kotlin.math.sqrt

fun main() {
    // ---------------------------
    // 입력 (문제에서 한 줄에 N개, M개 보장)
    // ---------------------------
    val n = readln().toInt()
    val a목록 = readln().split(" ").map { it.toLong() }.toMutableList()

    val m = readln().toInt()
    val b목록 = readln().split(" ").map { it.toLong() }.toMutableList()

    // ---------------------------
    // 소인수분해를 위해 필요한 소수 리스트 만들기
    //
    // 각 수는 1e9보다 작음.
    // 어떤 수 x의 소인수는 sqrt(x) 이하에서 반드시 하나는 발견됨.
    // 그래서 sqrt(1e9) 근처까지만 소수를 만들어두면 충분.
    // ---------------------------
    val 한계 = sqrt(1_000_000_000.0).toInt() + 1   // 약 31623
    val 소수이다 = BooleanArray(한계 + 1) { true }
    val 소수들 = mutableListOf<Long>()

    // 에라토스테네스의 체: 소수 i를 만나면, i의 배수들을 합성수로 표시
    for (i in 2..한계) {
        if (소수이다[i]) {
            //소수 찾았음.
            소수들.add(i.toLong())

            //이제 소수 제거하는 파트
            var j = i + i// i의 배수 2라면 41
            while (j <= 한계) {
                소수이다[j] = false
                j += i//i의 배수 2라면 6,8,10,12....
            }
        }
    }

    // ---------------------------
    // 한 숫자를 소인수분해해서 (소수 -> 지수) 맵에 누적하는 함수
    // 예) 72 = 2^3 * 3^2 => map[2]+=3, map[3]+=2
    // 소수목록에서 소수가 sqrt(72) 보다 커지면 이제 멈춰도 됨. 36,37,38...48이면 6까지만 반복하면 됨.
    // ---------------------------
    fun 소인수누적(값0: Long, 지수맵: MutableMap<Long, Long>) {
        var 값 = 값0

        //값0가 합성수라면..
        for (소수 in 소수들) {//에라체로 구한 소수목록을 순회함.
            if (소수 * 소수 > 값) break
            // [ 소수 > sqrt(값) ]을 제곱한것. 어떤 수 값이 합성수라면, 소인수 중 하나는 반드시 √값 이하에 있다.
            //합성수라면 √값 이하에서 소인수가 반드시 발견되므로 그 범위를 넘어가면 더 볼 필요가 없다.
            //그 결과로 남는 값은 “1이거나(다 분해됨) 합성수가 아닌 소수 그 자체”이므로, if (값 > 1)에서 마지막 소수 하나를 소인수로 수동 처리해 주는 것이다.
            if (값 % 소수 == 0L) {// 값 % k == 0 이면 k는 값의 약수(그 k가 소수라면 소인수) 즉, 값 % 소수 == 0 이면 소수는 값의 소인수.
                var 지수 = 0L//소인수이므로 그게 몇개인지 찾아야할 준비를 함.
                while (값 % 소수 == 0L) {// 찾으려면 안나눠질때까지 나눈 횟수를 세면 됨.
                    값 /= 소수
                    지수++
                }
                지수맵[소수] = (지수맵[소수] ?: 0) + 지수
            }
        }

        //값0가 소수라면...
        // 다 나눴는데 값이 1이 아니면 남은 값 자체가 소인수(지수 1)
        // 97, 29 같은 경우는 저 for문 전부 돌아도 아무일도 안일어남. 왜냐면 자신 자체로 소수이면 if (소수L * 소수L > 값) break에 걸려버림.
        // 저 break는 이제 소인수로 가능성 있는건 자기 자신밖에 없다. 이런 의미임.
        if (값 > 1L) {
            지수맵[값] = (지수맵[값] ?: 0) + 1
        }
    }

    // ---------------------------
    // A, B 각각에 대해 "소수 -> 전체 지수 합" 맵 만들기
    // ---------------------------
    val a소인수 = mutableMapOf<Long, Long>()
    val b소인수 = mutableMapOf<Long, Long>()

    for (x in a목록) 소인수누적(x, a소인수)
    for (x in b목록) 소인수누적(x, b소인수)

    // ---------------------------
    // gcd = 공통 소수 p에 대해 min(a지수[p], b지수[p]) 만큼 p를 곱한 값
    //
    // 단, 출력 조건: 9자리보다 길면 "마지막 9자리만" 출력.
    // => 곱할 때마다 mod 1e9로 마지막 9자리만 유지.
    // => 그리고 실제 gcd가 9자리를 넘었는지 여부는 플래그로 관리.
    // ---------------------------
    val 모듈 = 1_000_000_000L
    var 답 = 1L
    var 아홉자리초과 = false

    // a소인수 전체를 돌며 b지수에 있나 확인하고 공통이면 답 = 1에 쌓아감.
    for ((소수, aCnt) in a소인수) {
        val bCnt = b소인수[소수] ?: continue
        val 공통 = minOf(aCnt, bCnt)

        repeat(공통.toInt()) {
            // 곱하기 전 값이 1e9 이상으로 커질 가능성이 있으면 9자리 출력 모드
            if (!아홉자리초과 && 답 * (소수 % 모듈) >= 모듈) 아홉자리초과 = true
            // 마지막 9자리만 유지
            답 = (답 * (소수 % 모듈)) % 모듈
        }
    }

    // ---------------------------
    // 출력
    // - 9자리 넘어가면 9자리로 고정 출력(앞에 0도 포함)
    //   예) 12028 -> 000012028
    // - 아니면 그냥 출력
    // ---------------------------
    if (아홉자리초과) println(답.toString().padStart(9, '0'))
    else println(답)
}