package backjoon.`20260221`

import kotlin.math.sqrt

fun main() {
    // ---------------------------
    // 입력 (문제에서 한 줄에 N개, M개 보장)
    // ---------------------------
    val n = readln().toInt()
    val a목록 = readln().split(" ").map { it.toLong() }.toMutableList()

    val m = readln().toInt()
    val b목록 = readln().split(" ").map { it.toLong() }.toMutableList()

    // ---------------------------
    // 소인수분해를 위해 필요한 소수 리스트 만들기
    //
    // 각 수는 1e9보다 작음.
    // 어떤 수 x의 소인수는 sqrt(x) 이하에서 반드시 하나는 발견됨.
    // 그래서 sqrt(1e9) 근처까지만 소수를 만들어두면 충분.
    // ---------------------------
    val 한계 = sqrt(1_000_000_000.0).toInt() + 1   // 약 31623
    val 합성수체크 = BooleanArray(한계 + 1)
    val 소수들 = mutableListOf<Int>()

    // 에라토스테네스의 체: 소수 i를 만나면, i의 배수들을 합성수로 표시
    for (i in 2..한계) {
        if (!합성수체크[i]) {
            소수들.add(i)
            var j = i + i
            while (j <= 한계) {
                합성수체크[j] = true
                j += i
            }
        }
    }

    // ---------------------------
    // 한 숫자를 소인수분해해서 (소수 -> 지수) 맵에 누적하는 함수
    // 예) 72 = 2^3 * 3^2 => map[2]+=3, map[3]+=2
    // ---------------------------
    fun 소인수누적(값0: Long, 지수맵: MutableMap<Int, Int>) {
        var 값 = 값0

        for (소수 in 소수들) {//소수를 순회할것
            val 소수L = 소수.toLong()
            if (소수L * 소수L > 값) break// 소수 < sqrt(값)을 제곱한것. 어떤 수 값이 합성수라면, 소인수 중 하나는 반드시 √값 이하에 있어.

            if (값 % 소수L == 0L) {//소인수라면
                var 지수 = 0
                while (값 % 소수L == 0L) {
                    값 /= 소수L
                    지수++
                }
                지수맵[소수] = (지수맵[소수] ?: 0) + 지수
            }
        }

        // 다 나눴는데 값이 1이 아니면 남은 값 자체가 소인수(지수 1)
        if (값 > 1L) {
            val 남은소수 = 값.toInt()
            지수맵[남은소수] = (지수맵[남은소수] ?: 0) + 1
        }
    }

    // ---------------------------
    // A, B 각각에 대해 "소수 -> 전체 지수 합" 맵 만들기
    // ---------------------------
    val a지수 = mutableMapOf<Int, Int>()
    val b지수 = mutableMapOf<Int, Int>()

    for (x in a목록) 소인수누적(x, a지수)
    for (x in b목록) 소인수누적(x, b지수)

    // ---------------------------
    // gcd = 공통 소수 p에 대해 min(a지수[p], b지수[p]) 만큼 p를 곱한 값
    //
    // 단, 출력 조건: 9자리보다 길면 "마지막 9자리만" 출력.
    // => 곱할 때마다 mod 1e9로 마지막 9자리만 유지.
    // => 그리고 실제 gcd가 9자리를 넘었는지 여부는 플래그로 관리.
    // ---------------------------
    val 모듈 = 1_000_000_000L
    var 답 = 1L
    var 아홉자리초과 = false

    // a지수 전체를 돌며 b지수에 있나 확인
    for ((소수, aCnt) in a지수) {
        val bCnt = b지수[소수] ?: continue
        val 공통 = minOf(aCnt, bCnt)

        val 소수L = 소수.toLong()
        repeat(공통) {
            // 곱하기 전 값이 1e9 이상으로 커질 가능성이 있으면 9자리 출력 모드
            if (!아홉자리초과 && 답 * (소수L % 모듈) >= 모듈) 아홉자리초과 = true
            // 마지막 9자리만 유지
            답 = (답 * (소수L % 모듈)) % 모듈
        }
    }

    // ---------------------------
    // 출력
    // - 9자리 넘어가면 9자리로 고정 출력(앞에 0도 포함)
    //   예) 12028 -> 000012028
    // - 아니면 그냥 출력
    // ---------------------------
    if (아홉자리초과) println(답.toString().padStart(9, '0'))
    else println(답)
}