2 ~ N까지 소수목록을 구하는 방법이다. 소수가 아닌걸 전부 걸러내는 방식이다.
일단 모든 소수를 소수라고 먼저 가정한다.
이제 순회를 함. 2를 소수라고 가정했으니 소수목록에 넣음.(이는 사실)
그리고 2의 배수(4,6,8,...)를 전부 소수가 아니라고 표시함.

1은 소수 아니니 건너뛴다.
2는 소수이다.

![에라토스테네스의체.png](%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4.png)


`소인수누적` 함수는 입력으로 받은 자연수 `값0`를 소인수분해해서, 각 소수(소인수)가 몇 번 곱해졌는지(지수)를 `지수맵`에 누적하는 역할을 한다. 예를 들어 `72`는 `2 * 2 * 2 * 3 * 3` 이므로 `72 = 2^3 * 3^2`로 쓸 수 있고, 따라서 `지수맵[2]`에는 3을, `지수맵[3]`에는 2를 더해주는 식으로 결과를 기록한다.

이 함수를 빠르고 올바르게 만들기 위해 핵심적으로 사용하는 사실이 하나 있는데, 그것이 바로 “어떤 수 `값`이 합성수라면, 소인수 중 하나는 반드시 √값 이하에 있다”는 성질이다. 합성수라면 `값 = a * b` (a, b > 1)처럼 두 수의 곱으로 표현된다. 그런데 만약 a와 b가 둘 다 √값보다 크다면 `a*b`는 √값*√값보다 커지므로 값보다 커져버린다. 이는 `a*b = 값`이라는 가정과 모순이다. 따라서 합성수라면 둘 중 하나는 반드시 √값 이하이고, 결국 소인수도 √값 이하에서 하나는 반드시 발견된다. 이 말은 곧 “소인수 후보를 √값까지만 검사해도 합성수라면 반드시 걸린다”는 뜻이다.

그래서 코드에서는 소수 목록(`소수들`)을 작은 것부터 순회하면서, 현재 검사 중인 소수 `소수L`에 대해 `소수L * 소수L > 값`이 되는 순간 반복을 중단한다. 이 조건은 “지금 소수L이 √값보다 커졌다”와 같은 의미이고, 그 시점 이후로는 √값 이하의 소인수 후보가 더 이상 존재하지 않으므로 합성수라면 이미 앞에서 걸렸어야 한다. 즉, 그 순간부터는 더 나눠볼 필요가 없다.

반복문 안에서는 `값 % 소수L == 0`인지 확인한다. 이 조건이 참이면 `소수L`은 현재 `값`의 약수이고, 이미 소수 목록에서 꺼낸 값이므로 소수라는 것도 보장되어 있다. 따라서 `소수L`은 현재 `값`의 소인수가 된다. 이때 소인수분해에서는 같은 소인수가 여러 번 곱해져 있을 수 있으므로, `값`이 `소수L`로 더 이상 나누어떨어지지 않을 때까지 계속 나누면서 그 횟수를 세고(그게 지수), 그 지수를 `지수맵[소수]`에 누적한다. 예를 들어 72는 2로 세 번 나눠지므로 2의 지수가 3이 된다.

이 과정을 √값 이하의 소수들에 대해서만 수행하면, 합성수의 경우에는 필요한 소인수들이 모두 처리된다. 그러나 여기서 중요한 점은 “반복문이 끝났다고 해서 값이 반드시 1이 되는 것은 아니다”라는 것이다. 왜냐하면 반복문은 √값 이하까지만 검사하고 종료하기 때문이다. 만약 원래 `값0`가 합성수가 아니라 소수라면, √값 이하의 어떤 소수로도 나누어떨어지지 않는다. 이 경우 반복문은 결국 `소수L * 소수L > 값` 조건에서 종료되는데, 이때 남아 있는 `값`은 1이 아니라 원래의 소수 자체(예: 29, 97)로 남는다. 또한 합성수라도 작은 소인수들을 다 나누고 나면 마지막에 큰 소수 하나가 남을 수 있는데, 그 경우에도 √(남은 값) 이하에서 더 이상 나눌 수 없으므로 반복문이 끝나고 값이 1이 아닌 채로 남는다.

하지만 반복문이 `소수L * 소수L > 값` 때문에 끝난 시점에는 논리적으로 다음이 확정된다. “√값 이하의 소인수는 더 이상 존재하지 않는다.” 그런데 만약 `값`이 아직 1이 아니라면, 그 `값`은 합성수일 수 없다. 합성수라면 방금 말한 성질에 의해 √값 이하에 소인수가 하나는 반드시 있어야 하는데, 이미 그런 후보를 전부 검사했기 때문이다. 따라서 남아 있는 값은 합성수가 아닌 소수이고, 즉 그 자체가 소인수이다. 그래서 마지막에 `if (값 > 1)`이면 남은 값 자체를 지수 1로 `지수맵`에 추가하여 소인수분해를 완성한다.

정리하면, `if (소수L * 소수L > 값) break`는 “합성수라면 √값 이하에서 소인수가 반드시 발견되므로 그 범위를 넘어가면 더 볼 필요가 없다”는 논리를 코드로 표현한 것이고, 그 결과로 남는 `값`은 “1이거나(다 분해됨) 합성수가 아닌 소수 그 자체”이므로, `if (값 > 1)`에서 마지막 소수 하나를 소인수로 수동 처리해 주는 것이다.
