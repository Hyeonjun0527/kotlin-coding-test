# 수학 문법 암기장

## 시간 계산 (시:분:초)

### 초 단위로 바꾸려면?
"시간×3600 + 분×60 + 초"
```kotlin
val (h, m, s) = readln().split(":").map { it.toInt() }
val totalSec = h * 3600 + m * 60 + s
```

### 초를 시:분:초로 바꾸려면?

```txt
시 = 원래초 / 3600    ( 3600초짜리(=1시간) 묶음이 몇 개 들어있는지 )
원래초 %= 3600        (   시간으로 바꾸고 남은 나머지 초만 남김   )

분 = 원래초 / 60       (  남은 초에서 60초짜리(=1분) 묶음이 몇 개 들어있는지 )
원래초 %= 60          ( 분으로 바꾸고 남은 나머지 초”만 남김      )

초 = 원래초             (이제 남은 초는 0~59라서 그대로가 “초” 값임)
```

```txt
초 = 총초 % 60      ( 60으로 나눈 나머지 = “초” 단위(0~59) )
총초 /= 60          ( 초 단위를 떼고, “분 단위로 환산된 값”만 남김 )
분 = 총초 % 60      ( 60으로 나눈 나머지 = “분” 단위(0~59) )
총초 /= 60          ( 분 단위를 떼고, “시간 단위로 환산된 값”만 남김 )

시간 = 총초         ( 이제 남은 값은 전부 “시간” )
```
% 하는건 초단위 구하는거라 쉽게 이해됨. 근데 / 가 쉽게 이해 안될 수 있음.
이걸보자.
5000초 = 83 * 60 + 20초
83분 = 1 * 60 + 23분
결과 : 1시간 23분 20초
우리가 이미 20초를 뽑았으니까, 남은 건 **“몇 분인지”**만 알고 싶음.
그래서 60으로 나누면 초 단위 제외한 분 단위로 되는 것. 5000/60 = 83. 총 83분 됨.
이때 총초는 이름이 사실상 총분임. 또 60으로 나누면 사실상 총시간임. 


이 방법은 진수변환이랑 완전히 같은 방식임.
그럼 진수변환도 역으로 위에처럼 구할 수 있냐? 가능이야 한데 복잡해짐.
이유는 8진수도 “앞자리부터” 만들려면 나눗셈으로 자리수를 먼저 알아야 해서 복잡해져
앞자리부터 바로 뽑으려면 “가장 큰 8의 거듭제곱”을 찾아야 하니까,
기본 구현은 보통 뒤자리부터 간단하게 감.

"3600으로 나누고, 나머지를 60으로 나누기"

```kotlin
var sec = 5000
val hh = sec / 3600
sec %= 3600
val mm = sec / 60
sec %= 60
val ss = sec
```

```
val h = 값 / 3600
val m = (값 % 3600) / 60
val s = 값 % 60
```

"60으로 나눈 나머지 구하고, 60으로 나누기"
```kotlin
var sec = 5000
val ss = sec % 60
sec /= 60
val mm = sec % 60
sec /= 60
val hh = sec
```

음수 시간 처리?
"24시간 넘어가면 +24시간치"
```kotlin
var diff = time2 - time1
if (diff < 0) {
    diff += 24 * 3600
}
```

두 자리 숫자 포맷?
```kotlin
// 방법 1: 직접 만들기
fun two(n: Int) = if (n < 10) "0$n" else n.toString()
println(two(5))  // "05"

// 방법 2: format 사용
println("%02d:%02d:%02d".format(시간, 분, 초))
// %02d = 정수를 2자리로, 앞에 0 붙여서
```

## 진수 변환

10진수를 N진수로?
"N으로 나눈 나머지 모아서 뒤집기"
왜 %로 나누면 끝자리 알 수 있지?
나머지 = 찌꺼기 = 일의 자리

123 = 12 x 10 + 3
12 = 1 x 10 + 2
1 = 0 x 10 + 1
나머지 거꾸로 모으면 123

100 = 12 x 8 + 4
12 = 1 x 8 + 4
1 = 0 x 8 + 1
나머지 거꾸로 모으면 144

```kotlin
var n = 100
val digits = mutableListOf<Int>()
while (n > 0) {
    digits.add(n % 8)  // 8진수 예시
    n /= 8
}
digits.reverse()  // 제자리 정렬
```

2진수를 8진수로?
"3자리씩 묶어서 계산 (2³=8)"
```kotlin
var str = readln()
// 3의 배수 길이로 맞추기
if (str.length % 3 != 0) {
    val cnt = str.length % 3
    repeat(3 - cnt) {
        str = "0" + str
    }
}
// 3자리씩 읽기
val weights = arrayOf(4, 2, 1)
for (i in 0 until str.length step 3) {
    val octal = str[i].digitToInt() * 4 +
                str[i+1].digitToInt() * 2 +
                str[i+2].digitToInt() * 1
    print(octal)
}
```

문자를 숫자로?
```kotlin
'5'.digitToInt()     // 5
'5'.code - '0'.code  // 5 (같은 결과)
```

## 중복조합

3의 배수로만 고르기?
"step 사용해서 반복문 건너뛰기"
```kotlin
val n = 18
var cnt = 0
for (a in 3..n-6 step 3) {
    for (b in 3..n-a-3 step 3) {
        val c = n - a - b
        if (c >= 3 && c % 3 == 0) cnt++
    }
}
```

step이 뭐야?
"반복문 증가 간격 조절"
```kotlin
for (i in 1..10 step 2)  // 1, 3, 5, 7, 9
for (i in 10 downTo 1 step 2)  // 10, 8, 6, 4, 2
```

## GCD, LCM (최대공약수, 최소공배수)

GCD 구하기 (유클리드 호제법)?
"나머지가 0이 될 때까지"


```
gcd(x, y) = gcd(y, x % y)
gcd(48, 18) = gcd(18, 12)
gcd(18, 12) = gcd(12, 6)
gcd(12, 6) = gcd(6, 0)
gcd(6, 0) = 6
...
gcd(x, 0) = x
y가 0이면 멈춤.

GCD * LCM = x * y
LCM = (x / GCD) * y
왜? => 먼저 나눠서 오버플로우 방지
```


```kotlin
fun gcd(a: Int, b: Int): Int {
    var x = a// 코틀린은 파라미터가 val이라서 걍 옮긴거.
    var y = b
    while (y != 0) {
        val temp = x % y
        x = y
        y = temp
    }
    return x
}
// 또는 재귀
fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
```

LCM 구하기?
"GCD × LCM = a × b 공식 이용"
```kotlin
val gcd = gcd(a, b)
val lcm = (a / gcd) * b  // 먼저 나눠서 오버플로우 방지
// ❌ val lcm = a * b / gcd  // 오버플로우 위험!
```

왜 먼저 나눠?
"곱셈 먼저 하면 Int 범위 초과 가능성"
```kotlin
// a=1000000, b=1000000, gcd=1000
// a * b = 1조 → Int 범위 초과!
// (a/gcd) * b = 1000 * 1000000 = 10억 → OK
```

## 유용한 함수들

any - 하나라도 조건 만족?
```kotlin
val nums = listOf(1, 3, 5, 8)
nums.any { it % 2 == 0 }  // true (8이 짝수)
"abc3d".any { it.isDigit() }  // true
```

all - 전부 조건 만족?
```kotlin
val nums = listOf(2, 4, 6)
nums.all { it % 2 == 0 }  // true (전부 짝수)
"hello".all { it.isLowerCase() }  // true
```

reverse는 리턴? 제자리?
"제자리 정렬 (원본 변경)"
```kotlin
val list = mutableListOf(1, 2, 3)
list.reverse()  // list가 [3, 2, 1]로 변경됨
// reversed()는 새 리스트 반환
val rev = list.reversed()  // 원본 유지
```
