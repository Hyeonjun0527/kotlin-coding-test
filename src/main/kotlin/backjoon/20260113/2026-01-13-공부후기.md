1️⃣ 나눗셈 결과 기준 (n / d 를 정수로 처리)

| 목적                     | 공식                   | 예 (n=7, d=4) |
|-------------------------|------------------------|---------------|
| 정수 나눗셈 **올림**       | (n + d - 1) / d        | 2             |
| 정수 나눗셈 **반올림**     | (n + d/2) / d          | 2             |
| 정수 나눗셈 **버림**       | n / d                  | 1             |

버림 : 걍하면 대.

반올림 : d/2 더하면 대.

올림 : d - 1 더하면 대.

2️⃣ 숫자 자체를 d 단위로 처리 (예: 10단위 반올림)

| 목적                   | 공식                       | 예 (n=127, d=10) |
|-----------------------|----------------------------|------------------|
| d 단위 **올림**         | ((n + d - 1) / d) * d       | 130              |
| d 단위 **반올림**       | ((n + d/2) / d) * d         | 130              |
| d 단위 **버림**         | (n / d) * d                 | 120              |


만약동전문제 배수인게 유지가 안된다면 어떻게 풀어야하는지 알아보기

### 배열 클리어
| 타입                | 비우는 법             |
|--------------------|-----------------------|
| MutableList        | list.clear()          |
| ArrayDeque         | q.clear()             |
| MutableSet         | set.clear()           |
| MutableMap         | map.clear()           |
| BooleanArray       | arr.fill(false)       |
| IntArray           | arr.fill(0)           |
| 기타 Array         | arr.fill(defaultValue)|
| StringBuilder      | sb.clear() 또는 sb.setLength(0) |

핵심 기억 포인트
- **clear()는 컬렉션(MutableList/Set/Map/Deque) 전용**
- **배열(Array 계열)은 clear()가 없어서 fill()로 덮어씀**
- **StringBuilder는 clear() 또는 setLength(0)**


### previousNode 구하기

```kotlin
val prev = IntArray(n) { -1 }
val q = ArrayDeque<Int>()

q.add(start)
prev[start] = start

while (q.isNotEmpty()) {
    val cur = q.removeFirst()
    for (next in graph[cur]) {
        if (prev[next] == -1) {
            prev[next] = cur
            q.add(next)
        }
    }
}
```

### 경로 되살리기
```kotlin
val path = mutableListOf<Int>()
var x = end
while (x != start) {
path.add(x)
x = prev[x]
}
path.add(start)
path.reverse()
```